.TH "scratchpad.c" 3 "Sun Nov 30 2014" "howm" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scratchpad.c \- 
.PP
The stack implementation and appropriate functions required for sending clients (or groups of clients) to the scratchpad\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include 'scratchpad\&.h'\fP
.br
\fC#include 'client\&.h'\fP
.br
\fC#include 'config\&.h'\fP
.br
\fC#include 'helper\&.h'\fP
.br
\fC#include 'workspace\&.h'\fP
.br
\fC#include 'howm\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBstack_init\fP (struct \fBstack\fP *s)"
.br
.RI "\fIDynamically allocate space for the contents of the stack\&. \fP"
.ti -1c
.RI "void \fBstack_free\fP (struct \fBstack\fP *s)"
.br
.RI "\fIFree the allocated contents\&. \fP"
.ti -1c
.RI "void \fBstack_push\fP (struct \fBstack\fP *s, \fBClient\fP *c)"
.br
.RI "\fIPushes a client onto the stack, as long as it isn't full\&. \fP"
.ti -1c
.RI "\fBClient\fP * \fBstack_pop\fP (struct \fBstack\fP *s)"
.br
.RI "\fIRemove the top item from the stack and return it\&. \fP"
.ti -1c
.RI "void \fBsend_to_scratchpad\fP (void)"
.br
.RI "\fISend a client to the scratchpad and unmap it\&. \fP"
.ti -1c
.RI "void \fBget_from_scratchpad\fP (void)"
.br
.RI "\fIGet a client from the scratchpad, attach it as the last item in the client list and set it to float\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct \fBstack\fP \fBdel_reg\fP"
.br
.ti -1c
.RI "static \fBClient\fP * \fBscratchpad\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The stack implementation and appropriate functions required for sending clients (or groups of clients) to the scratchpad\&. 


.PP
\fBAuthor:\fP
.RS 4
Harvey Hunt
.RE
.PP
\fBDate:\fP
.RS 4
2014 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void get_from_scratchpad (void)"

.PP
Get a client from the scratchpad, attach it as the last item in the client list and set it to float\&. TODO: Move this into \fBcommand\&.c\fP 
.SS "void send_to_scratchpad (void)"

.PP
Send a client to the scratchpad and unmap it\&. TODO: Move this into \fBcommand\&.c\fP 
.SS "void stack_free (struct \fBstack\fP *s)"

.PP
Free the allocated contents\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The stack that needs to have its contents freed\&. 
.RE
.PP

.SS "void stack_init (struct \fBstack\fP *s)"

.PP
Dynamically allocate space for the contents of the stack\&. We don't know how big the stack will be when the struct is defined, so we need to allocate it dynamically\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The stack that needs to have its contents allocated\&. 
.RE
.PP

.SS "\fBClient\fP* stack_pop (struct \fBstack\fP *s)"

.PP
Remove the top item from the stack and return it\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The stack to be popped from\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The client that was at the top of the stack\&. It acts as the head of the linked list of clients\&. 
.RE
.PP

.SS "void stack_push (struct \fBstack\fP *s, \fBClient\fP *c)"

.PP
Pushes a client onto the stack, as long as it isn't full\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The stack\&. 
.br
\fIc\fP The client to be pushed on\&. This client is treated as the head of a linked list\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "struct \fBstack\fP del_reg"

.SS "\fBClient\fP* scratchpad\fC [static]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for howm from the source code\&.
