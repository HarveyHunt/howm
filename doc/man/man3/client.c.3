.TH "client.c" 3 "Sun Nov 30 2014" "howm" \" -*- nroff -*-
.ad l
.nh
.SH NAME
client.c \- 
Operations that are to be performed on clients, such as moving them around in the client list\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <xcb/xcb\&.h>\fP
.br
\fC#include <xcb/xcb_ewmh\&.h>\fP
.br
\fC#include <xcb/xcb_icccm\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'client\&.h'\fP
.br
\fC#include 'workspace\&.h'\fP
.br
\fC#include 'layout\&.h'\fP
.br
\fC#include 'command\&.h'\fP
.br
\fC#include 'config\&.h'\fP
.br
\fC#include 'helper\&.h'\fP
.br
\fC#include 'howm\&.h'\fP
.br
\fC#include 'xcb_help\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBmove_down\fP (\fBClient\fP *c)"
.br
.RI "\fIMove a client down in its client list\&. \fP"
.ti -1c
.RI "\fBClient\fP * \fBfind_client_by_win\fP (xcb_window_t win)"
.br
.RI "\fISearch workspaces for a window, returning the client that it belongs to\&. \fP"
.ti -1c
.RI "\fBClient\fP * \fBprev_client\fP (\fBClient\fP *c, int ws)"
.br
.RI "\fIFind the client before the given client\&. \fP"
.ti -1c
.RI "\fBClient\fP * \fBnext_client\fP (\fBClient\fP *c)"
.br
.RI "\fIFind the next client\&. \fP"
.ti -1c
.RI "void \fBupdate_focused_client\fP (\fBClient\fP *c)"
.br
.RI "\fISets c to the active window and gives it input focus\&. Sorts out border colours as well\&. \fP"
.ti -1c
.RI "int \fBget_non_tff_count\fP (void)"
.br
.RI "\fICount how many clients aren't Transient, Floating or Fullscreen\&. \fP"
.ti -1c
.RI "\fBClient\fP * \fBget_first_non_tff\fP (void)"
.br
.RI "\fIReturns the first client that isn't transient, floating or fullscreen\&. \fP"
.ti -1c
.RI "void \fBremove_client\fP (\fBClient\fP *c, bool refocus)"
.br
.RI "\fIRemove a client from its workspace client list\&. \fP"
.ti -1c
.RI "void \fBmove_up\fP (\fBClient\fP *c)"
.br
.RI "\fIMove a client up in its client list\&. \fP"
.ti -1c
.RI "void \fBfocus_next_client\fP (void)"
.br
.RI "\fIbrief Move focus onto the client next in the client list\&. \fP"
.ti -1c
.RI "void \fBfocus_prev_client\fP (void)"
.br
.RI "\fIbrief Move focus onto the client previous in the client list\&. \fP"
.ti -1c
.RI "void \fBkill_client\fP (const int ws, bool arrange)"
.br
.RI "\fIKills the current client on the workspace ws\&. \fP"
.ti -1c
.RI "void \fBmove_client\fP (int cnt, bool up)"
.br
.RI "\fIMoves a client either upwards or down\&. \fP"
.ti -1c
.RI "void \fBmove_current_down\fP (void)"
.br
.RI "\fIMoves the current client down\&. \fP"
.ti -1c
.RI "void \fBmove_current_up\fP (void)"
.br
.RI "\fIMoves the current client up\&. \fP"
.ti -1c
.RI "void \fBclient_to_ws\fP (\fBClient\fP *c, const int ws, bool follow)"
.br
.RI "\fIMoves a client from one workspace to another\&. \fP"
.ti -1c
.RI "void \fBdraw_clients\fP (void)"
.br
.RI "\fIArrange the client's windows on the screen\&. \fP"
.ti -1c
.RI "void \fBchange_client_geom\fP (\fBClient\fP *c, uint16_t x, uint16_t y, uint16_t w, uint16_t h)"
.br
.RI "\fIChange the size and location of a client\&. \fP"
.ti -1c
.RI "void \fBchange_client_gaps\fP (\fBClient\fP *c, int size)"
.br
.RI "\fIA helper function to change the size of a client's gaps\&. \fP"
.ti -1c
.RI "\fBClient\fP * \fBcreate_client\fP (xcb_window_t w)"
.br
.RI "\fIConvert a window into a client\&. \fP"
.ti -1c
.RI "void \fBset_fullscreen\fP (\fBClient\fP *c, bool fscr)"
.br
.RI "\fISet the fullscreen state of the client\&. Change its geometry and border widths\&. \fP"
.ti -1c
.RI "void \fBset_urgent\fP (\fBClient\fP *c, bool urg)"
.br
.ti -1c
.RI "void \fBapply_rules\fP (\fBClient\fP *c)"
.br
.RI "\fISet the properties of a client that has just been created, according to the rules defined in the config file\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Operations that are to be performed on clients, such as moving them around in the client list\&. 


.PP
\fBAuthor:\fP
.RS 4
Harvey Hunt
.RE
.PP
\fBDate:\fP
.RS 4
2014 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void apply_rules (\fBClient\fP *c)"

.PP
Set the properties of a client that has just been created, according to the rules defined in the config file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client that has been created\&. 
.RE
.PP

.SS "void change_client_gaps (\fBClient\fP *c, intsize)"

.PP
A helper function to change the size of a client's gaps\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client who's gap size should be changed\&. 
.br
\fIsize\fP The size by which the gap should be changed\&. 
.RE
.PP

.SS "void change_client_geom (\fBClient\fP *c, uint16_tx, uint16_ty, uint16_tw, uint16_th)"

.PP
Change the size and location of a client\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client to be changed\&. 
.br
\fIx\fP The x coordinate of the client's window\&. 
.br
\fIy\fP The y coordinate of the client's window\&. 
.br
\fIw\fP The width of the client's window\&. 
.br
\fIh\fP The height of the client's window\&. 
.RE
.PP

.SS "void client_to_ws (\fBClient\fP *c, const intws, boolfollow)"

.PP
Moves a client from one workspace to another\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client to be moved\&. 
.br
\fIws\fP The ws that the client should be moved to\&. 
.br
\fIfollow\fP Should focus follow the client that has been moved? 
.RE
.PP

.SS "\fBClient\fP* create_client (xcb_window_tw)"

.PP
Convert a window into a client\&. 
.PP
\fBParameters:\fP
.RS 4
\fIw\fP A valid xcb window\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A client that has already been inserted into the linked list of clients\&. 
.RE
.PP

.SS "void draw_clients (void)"

.PP
Arrange the client's windows on the screen\&. This function takes some strain off of the layout handlers by passing the client's dimensions to move_resize\&. This splits the layout handlers into smaller, more understandable parts\&. 
.SS "\fBClient\fP* find_client_by_win (xcb_window_twin)"

.PP
Search workspaces for a window, returning the client that it belongs to\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwin\fP A valid XCB window that is used when searching all clients across all desktops\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The found client\&. 
.RE
.PP

.SS "void focus_next_client (void)"

.PP
brief Move focus onto the client next in the client list\&. 
.SS "void focus_prev_client (void)"

.PP
brief Move focus onto the client previous in the client list\&. 
.SS "\fBClient\fP* get_first_non_tff (void)"

.PP
Returns the first client that isn't transient, floating or fullscreen\&. 
.PP
\fBReturns:\fP
.RS 4
The first client that isn't TFF\&. NULL if none\&. 
.RE
.PP

.SS "int get_non_tff_count (void)"

.PP
Count how many clients aren't Transient, Floating or Fullscreen\&. 
.PP
\fBReturns:\fP
.RS 4
The amount of clients in the current workspace that aren't TFF\&. 
.RE
.PP

.SS "void kill_client (const intws, boolarrange)"

.PP
Kills the current client on the workspace ws\&. 
.PP
\fBParameters:\fP
.RS 4
\fIws\fP The workspace that the current client to be killed is on\&.
.br
\fIarrange\fP Whether the windows should be rearranged\&. 
.RE
.PP

.SS "void move_client (intcnt, boolup)"

.PP
Moves a client either upwards or down\&. Moves a single client or multiple clients either up or down\&. The op_move_* functions serves as simple wrappers to this\&.
.PP
\fBParameters:\fP
.RS 4
\fIcnt\fP How many clients to move\&. 
.br
\fIup\fP Whether to move the clients up or down\&. True is up\&. 
.RE
.PP

.SS "void move_current_down (void)"

.PP
Moves the current client down\&. 
.SS "void move_current_up (void)"

.PP
Moves the current client up\&. 
.SS "static void move_down (\fBClient\fP *c)\fC [static]\fP"

.PP
Move a client down in its client list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client to be moved\&. 
.RE
.PP

.SS "void move_up (\fBClient\fP *c)"

.PP
Move a client up in its client list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client to be moved down\&. 
.RE
.PP

.SS "\fBClient\fP* next_client (\fBClient\fP *c)"

.PP
Find the next client\&. Note: This function wraps around the end of the list of clients\&. If c is the last item in the list of clients, then the head of the list is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client which needs to have its next found\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The next client, if c is the last client in the list then this will be head\&. If c is NULL or there is only one client in the client list, NULL will be returned\&. 
.RE
.PP

.SS "\fBClient\fP* prev_client (\fBClient\fP *c, intws)"

.PP
Find the client before the given client\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client which needs to have its previous found\&.
.br
\fIws\fP The workspace that the client is on\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The previous client, so long as the given client isn't NULL and there is more than one client\&. Else, NULL\&. 
.RE
.PP

.SS "void remove_client (\fBClient\fP *c, boolrefocus)"

.PP
Remove a client from its workspace client list\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client to be removed\&.
.br
\fIrefocus\fP Whether the clients should be rearranged and focus be updated\&. 
.RE
.PP

.SS "void set_fullscreen (\fBClient\fP *c, boolfscr)"

.PP
Set the fullscreen state of the client\&. Change its geometry and border widths\&. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client which should have its fullscreen state altered\&. 
.br
\fIfscr\fP The fullscreen state that the client should be changed to\&. 
.RE
.PP

.SS "void set_urgent (\fBClient\fP *c, boolurg)"

.SS "void update_focused_client (\fBClient\fP *c)"

.PP
Sets c to the active window and gives it input focus\&. Sorts out border colours as well\&. WARNING: Do NOT use this to focus a client on another workspace\&. Instead, set wss[ws]\&.current to the client that you want focused\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The client that is currently in focus\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for howm from the source code\&.
