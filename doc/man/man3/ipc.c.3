.TH "ipc.c" 3 "Sun Nov 30 2014" "howm" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ipc.c \- 
.PP
Everything required to parse, interpret and respond to messages that are sent over IPC\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <sys/un\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include 'command\&.h'\fP
.br
\fC#include 'scratchpad\&.h'\fP
.br
\fC#include 'op\&.h'\fP
.br
\fC#include 'ipc\&.h'\fP
.br
\fC#include 'helper\&.h'\fP
.br
\fC#include 'howm\&.h'\fP
.br
\fC#include 'config\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSET_INT\fP(opt, arg, lower, upper)"
.br
.ti -1c
.RI "#define \fBSET_BOOL\fP(opt, arg)"
.br
.ti -1c
.RI "#define \fBSET_COLOUR\fP(opt, arg)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBmsg_type\fP { \fBMSG_FUNCTION\fP = 1, \fBMSG_CONFIG\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static char ** \fBipc_process_args\fP (char *msg, int len, int *err)"
.br
.RI "\fIAccepts a char array and convert it into an array of strings\&. \fP"
.ti -1c
.RI "static int \fBipc_arg_to_int\fP (char *arg, int *err, int lower, int upper)"
.br
.RI "\fIConvert a numerical string into a decimal value, such as '12' becoming 12\&. \fP"
.ti -1c
.RI "static int \fBipc_process_function\fP (char **args)"
.br
.RI "\fIReceive a char array from a UNIX socket and subsequently call a function, passing the args from within msg\&. \fP"
.ti -1c
.RI "static int \fBipc_process_config\fP (char **args)"
.br
.ti -1c
.RI "static bool \fBipc_arg_to_bool\fP (char *arg, int *err)"
.br
.ti -1c
.RI "int \fBipc_init\fP (void)"
.br
.ti -1c
.RI "int \fBipc_process\fP (char *msg, int len)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Everything required to parse, interpret and respond to messages that are sent over IPC\&. 


.PP
\fBAuthor:\fP
.RS 4
Harvey Hunt
.RE
.PP
\fBDate:\fP
.RS 4
2014 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define SET_BOOL(opt, arg)"
\fBValue:\fP
.PP
.nf
do { \
                b = ipc_arg_to_bool(arg, &err); \
                        if (err == IPC_ERR_NONE) \
                                opt = b; \
        } while (0)
.fi
.SS "#define SET_COLOUR(opt, arg)"
\fBValue:\fP
.PP
.nf
do { \
                if (strlen(arg) > 7) \
                        return IPC_ERR_ARG_TOO_LARGE; \
                else if (strlen(arg) < 7) \
                        return IPC_ERR_ARG_TOO_SMALL; \
                opt = get_colour(arg); \
        } while (0)
.fi
.SS "#define SET_INT(opt, arg, lower, upper)"
\fBValue:\fP
.PP
.nf
do { \
                i = ipc_arg_to_int(arg, &err, lower, upper); \
                        if (err == IPC_ERR_NONE) \
                                opt = i; \
        } while (0)
.fi
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBmsg_type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIMSG_FUNCTION \fP\fP
.TP
\fB\fIMSG_CONFIG \fP\fP
.SH "Function Documentation"
.PP 
.SS "static bool ipc_arg_to_bool (char *arg, int *err)\fC [static]\fP"

.SS "static int ipc_arg_to_int (char *arg, int *err, intlower, intupper)\fC [static]\fP"

.PP
Convert a numerical string into a decimal value, such as '12' becoming 12\&. Minus signs are handled\&. It is assumed that a two digit number won't start with a zero\&. Args with more than two digits will not be accepted, nor will args that aren't numerical\&.
.PP
\fBParameters:\fP
.RS 4
\fIarg\fP The string to be converted\&. 
.br
\fIerr\fP Where errors are reported\&. 
.br
\fIlower\fP The lower bound for the returned value\&. Note: This is inclusive 
.br
\fIupper\fP The upper bound for the returned value\&. Note: This is inclusive
.RE
.PP
\fBReturns:\fP
.RS 4
The decimal representation of arg\&. 
.RE
.PP

.SS "int ipc_init (void)"

.SS "int ipc_process (char *msg, intlen)"

.SS "static char ** ipc_process_args (char *msg, intlen, int *err)\fC [static]\fP"

.PP
Accepts a char array and convert it into an array of strings\&. msg is split into strings (delimited by a null character) and placed in an array\&. err is set with a corresponding error (such as args too few args), or nothing\&.
.PP
XXX: args must be freed by the caller\&.
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP A char array that is read from a UNIX socket\&. 
.br
\fIlen\fP The length of data in msg\&. 
.br
\fIerr\fP Where any errors will be stored\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to an array of strings, each one representing an argument that has been passed over a UNIX socket\&. 
.RE
.PP

.SS "static int ipc_process_config (char **args)\fC [static]\fP"

.SS "static int ipc_process_function (char **args)\fC [static]\fP"

.PP
Receive a char array from a UNIX socket and subsequently call a function, passing the args from within msg\&. 
.PP
\fBParameters:\fP
.RS 4
\fIargs\fP The args (as strings)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The error code, as set by this function itself or those that it calls\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for howm from the source code\&.
