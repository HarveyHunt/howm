.TH "command.c" 3 "Sun Nov 30 2014" "howm" \" -*- nroff -*-
.ad l
.nh
.SH NAME
command.c \- 
.PP
Commands are bound to keybindings or are executed as a result of a message from IPC\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <xcb/xcb_ewmh\&.h>\fP
.br
\fC#include 'command\&.h'\fP
.br
\fC#include 'workspace\&.h'\fP
.br
\fC#include 'helper\&.h'\fP
.br
\fC#include 'howm\&.h'\fP
.br
\fC#include 'client\&.h'\fP
.br
\fC#include 'layout\&.h'\fP
.br
\fC#include 'scratchpad\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBchange_mode\fP (const int mode)"
.br
.RI "\fIChange the mode of howm\&. \fP"
.ti -1c
.RI "void \fBtoggle_float\fP (void)"
.br
.RI "\fIToggle a client between being in a floating or non-floating state\&. \fP"
.ti -1c
.RI "void \fBresize_float_width\fP (const int dw)"
.br
.RI "\fIChange the width of a floating client\&. \fP"
.ti -1c
.RI "void \fBresize_float_height\fP (const int dh)"
.br
.RI "\fIChange the height of a floating client\&. \fP"
.ti -1c
.RI "void \fBmove_float_y\fP (const int dy)"
.br
.RI "\fIChange a floating window's y coordinate\&. \fP"
.ti -1c
.RI "void \fBmove_float_x\fP (const int dx)"
.br
.RI "\fIChange a floating window's x coordinate\&. \fP"
.ti -1c
.RI "void \fBteleport_client\fP (const int direction)"
.br
.RI "\fITeleport a floating client's window to a location on the screen\&. \fP"
.ti -1c
.RI "void \fBresize_master\fP (const int ds)"
.br
.RI "\fIResize the master window of a stack for the current workspace\&. \fP"
.ti -1c
.RI "void \fBtoggle_bar\fP (void)"
.br
.RI "\fIToggle the space reserved for a status bar\&. \fP"
.ti -1c
.RI "void \fBmake_master\fP (void)"
.br
.RI "\fIMoves the current window to the master window, when in stack mode\&. \fP"
.ti -1c
.RI "void \fBpaste\fP (void)"
.br
.RI "\fIRemove a list of clients from howm's delete register stack and paste them after the currently focused window\&. \fP"
.ti -1c
.RI "void \fBchange_layout\fP (const int layout)"
.br
.RI "\fIChange the layout of the current workspace\&. \fP"
.ti -1c
.RI "void \fBprev_layout\fP (void)"
.br
.RI "\fIChange to the previous layout\&. \fP"
.ti -1c
.RI "void \fBnext_layout\fP (void)"
.br
.RI "\fIChange to the next layout\&. \fP"
.ti -1c
.RI "void \fBlast_layout\fP (void)"
.br
.RI "\fIChange to the last used layout\&. \fP"
.ti -1c
.RI "void \fBrestart_howm\fP (void)"
.br
.RI "\fIRestart howm\&. \fP"
.ti -1c
.RI "void \fBquit_howm\fP (const int exit_status)"
.br
.RI "\fIQuit howm and set the return value\&. \fP"
.ti -1c
.RI "void \fBtoggle_fullscreen\fP (void)"
.br
.RI "\fIToggle the fullscreen state of the current client\&. \fP"
.ti -1c
.RI "void \fBfocus_urgent\fP (void)"
.br
.RI "\fIFocus a client that has an urgent hint\&. \fP"
.ti -1c
.RI "void \fBspawn\fP (char *cmd[])"
.br
.RI "\fISpawns a command\&. \fP"
.ti -1c
.RI "void \fBfocus_prev_ws\fP (void)"
.br
.RI "\fIFocus the previous workspace\&. \fP"
.ti -1c
.RI "void \fBfocus_last_ws\fP (void)"
.br
.RI "\fIFocus the last focused workspace\&. \fP"
.ti -1c
.RI "void \fBfocus_next_ws\fP (void)"
.br
.RI "\fIFocus the next workspace\&. \fP"
.ti -1c
.RI "void \fBchange_ws\fP (const int ws)"
.br
.RI "\fIChange to a different workspace and map the correct windows\&. \fP"
.ti -1c
.RI "void \fBcount\fP (const int cnt)"
.br
.RI "\fISet the current count for the current operator\&. \fP"
.ti -1c
.RI "void \fBmotion\fP (char *target)"
.br
.RI "\fITell howm which motion is to be performed\&. \fP"
.ti -1c
.RI "void \fBcurrent_to_ws\fP (const int ws)"
.br
.RI "\fIMoves the current client to the workspace passed in\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static int \fBcur_cnt\fP = 1"
.br
.in -1c
.SH "Detailed Description"
.PP 
Commands are bound to keybindings or are executed as a result of a message from IPC\&. 


.PP
\fBAuthor:\fP
.RS 4
Harvey Hunt
.RE
.PP
\fBDate:\fP
.RS 4
2014 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void change_layout (const intlayout)"

.PP
Change the layout of the current workspace\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlayout\fP Represents the layout that should be used\&. 
.RE
.PP

.SS "void change_mode (const intmode)"

.PP
Change the mode of howm\&. Modes should be thought of in the same way as they are in vi\&. Different modes mean keypresses cause different actions\&.
.PP
\fBParameters:\fP
.RS 4
\fImode\fP The mode to be selected\&. 
.RE
.PP

.SS "void change_ws (const intws)"

.PP
Change to a different workspace and map the correct windows\&. 
.PP
\fBParameters:\fP
.RS 4
\fIws\fP Indicates which workspace howm should change to\&. 
.RE
.PP

.SS "void count (const intcnt)"

.PP
Set the current count for the current operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcnt\fP The amount of motions the operator should affect\&. 
.RE
.PP

.SS "void current_to_ws (const intws)"

.PP
Moves the current client to the workspace passed in\&. 
.PP
\fBParameters:\fP
.RS 4
\fIws\fP The target workspace\&. 
.RE
.PP

.SS "void focus_last_ws (void)"

.PP
Focus the last focused workspace\&. 
.SS "void focus_next_ws (void)"

.PP
Focus the next workspace\&. 
.SS "void focus_prev_ws (void)"

.PP
Focus the previous workspace\&. 
.SS "void focus_urgent (void)"

.PP
Focus a client that has an urgent hint\&. 
.SS "void last_layout (void)"

.PP
Change to the last used layout\&. 
.SS "void make_master (void)"

.PP
Moves the current window to the master window, when in stack mode\&. 
.SS "void motion (char *target)"

.PP
Tell howm which motion is to be performed\&. This allows keybinding using an external program to still use operators\&.
.PP
\fBParameters:\fP
.RS 4
\fItarget\fP A single char representing the motion that the operator should be applied to\&. 
.RE
.PP

.SS "void move_float_x (const intdx)"

.PP
Change a floating window's x coordinate\&. Negative values will move the window to the left\&. The inverse is true for positive values\&.
.PP
\fBParameters:\fP
.RS 4
\fIdx\fP The amount of pixels that the window should be moved\&. 
.RE
.PP

.SS "void move_float_y (const intdy)"

.PP
Change a floating window's y coordinate\&. Negative values will move the window up\&. The inverse is true for positive values\&.
.PP
\fBParameters:\fP
.RS 4
\fIdy\fP The amount of pixels that the window should be moved\&. 
.RE
.PP

.SS "void next_layout (void)"

.PP
Change to the next layout\&. 
.SS "void paste (void)"

.PP
Remove a list of clients from howm's delete register stack and paste them after the currently focused window\&. 
.SS "void prev_layout (void)"

.PP
Change to the previous layout\&. 
.SS "void quit_howm (const intexit_status)"

.PP
Quit howm and set the return value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIexit_status\fP The return value that howm will send\&. 
.RE
.PP

.SS "void resize_float_height (const intdh)"

.PP
Change the height of a floating client\&. Negative values will shift the bottom edge of the window to the top\&. The inverse is true for positive values\&.
.PP
\fBParameters:\fP
.RS 4
\fIdh\fP The amount of pixels that the window's size should be changed by\&. 
.RE
.PP

.SS "void resize_float_width (const intdw)"

.PP
Change the width of a floating client\&. Negative values will shift the right edge of the window to the left\&. The inverse is true for positive values\&.
.PP
\fBParameters:\fP
.RS 4
\fIdw\fP The amount of pixels that the window's size should be changed by\&. 
.RE
.PP

.SS "void resize_master (const intds)"

.PP
Resize the master window of a stack for the current workspace\&. 
.PP
\fBParameters:\fP
.RS 4
\fIds\fP The amount to resize the master window by\&. Treated as a percentage\&. e\&.g\&. ds = 5 will increase the master window's size by 5% of it maximum\&. 
.RE
.PP

.SS "void restart_howm (void)"

.PP
Restart howm\&. 
.SS "void spawn (char *cmd[])"

.PP
Spawns a command\&. 
.SS "void teleport_client (const intdirection)"

.PP
Teleport a floating client's window to a location on the screen\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdirection\fP Which location to teleport the window to\&. 
.RE
.PP

.SS "void toggle_bar (void)"

.PP
Toggle the space reserved for a status bar\&. 
.SS "void toggle_float (void)"

.PP
Toggle a client between being in a floating or non-floating state\&. 
.SS "void toggle_fullscreen (void)"

.PP
Toggle the fullscreen state of the current client\&. 
.SH "Variable Documentation"
.PP 
.SS "int cur_cnt = 1\fC [static]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for howm from the source code\&.
